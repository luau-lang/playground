/**
 * Vite plugin to compile Oniguruma regex patterns from the Luau TextMate grammar
 * to native JavaScript RegExp patterns at build time.
 * 
 * This eliminates the need for oniguruma-to-es at runtime.
 * 
 * Usage:
 *   import { compiledPatterns } from 'virtual:compiled-patterns';
 */

import type { Plugin } from 'vite';
import { toRegExp } from 'oniguruma-to-es';
import { readFileSync } from 'fs';
import { resolve } from 'path';

const VIRTUAL_MODULE_ID = 'virtual:compiled-patterns';
const RESOLVED_VIRTUAL_MODULE_ID = '\0' + VIRTUAL_MODULE_ID;

interface GrammarNode {
  match?: string;
  begin?: string;
  end?: string;
  while?: string;
  patterns?: GrammarNode[];
  repository?: Record<string, GrammarNode>;
  captures?: Record<string, GrammarNode>;
  beginCaptures?: Record<string, GrammarNode>;
  endCaptures?: Record<string, GrammarNode>;
  whileCaptures?: Record<string, GrammarNode>;
  [key: string]: unknown;
}

/**
 * Extract all unique regex patterns from the grammar.
 */
function extractPatterns(obj: unknown, patterns = new Set<string>()): Set<string> {
  if (!obj || typeof obj !== 'object') return patterns;
  
  if (Array.isArray(obj)) {
    for (const item of obj) {
      extractPatterns(item, patterns);
    }
  } else {
    const node = obj as GrammarNode;
    // Check for pattern properties
    for (const key of ['match', 'begin', 'end', 'while'] as const) {
      if (typeof node[key] === 'string') {
        patterns.add(node[key]);
      }
    }
    // Recurse into nested objects
    for (const value of Object.values(node)) {
      extractPatterns(value, patterns);
    }
  }
  
  return patterns;
}

/**
 * Compile all patterns to JavaScript RegExp.
 */
function compilePatterns(patterns: string[]): Record<string, [string, string] | null> {
  const compiled: Record<string, [string, string] | null> = {};
  
  for (const pattern of patterns) {
    try {
      const regex = toRegExp(pattern, {
        global: true,
        hasIndices: true,
        rules: {
          allowOrphanBackrefs: true,
          asciiWordBoundaries: true,
          captureGroup: true,
          recursionLimit: 5,
          singleline: true,
        },
        target: 'ES2024',
      });
      
      // Store as [source, flags] tuple
      compiled[pattern] = [regex.source, regex.flags];
    } catch {
      // Store null for patterns that couldn't be compiled
      compiled[pattern] = null;
    }
  }
  
  return compiled;
}

/**
 * Generate the virtual module code.
 */
function generateModule(compiledPatterns: Record<string, [string, string] | null>): string {
  const total = Object.keys(compiledPatterns).length;
  const failed = Object.values(compiledPatterns).filter(v => v === null).length;
  
  return `/**
 * Pre-compiled regex patterns for the Luau TextMate grammar.
 * Generated by vite/compile-grammar.ts
 * 
 * Total patterns: ${total}
 * Successfully compiled: ${total - failed}
 * Failed: ${failed}
 */

export const compiledPatterns = ${JSON.stringify(compiledPatterns, null, 2)};
`;
}

export function compileGrammarPlugin(): Plugin {
  let grammarPath: string;
  let cachedModule: string | null = null;
  
  return {
    name: 'compile-grammar',
    
    configResolved(config) {
      grammarPath = resolve(config.root, 'src/lib/editor/Luau.tmLanguage.json');
    },
    
    resolveId(id) {
      if (id === VIRTUAL_MODULE_ID) {
        return RESOLVED_VIRTUAL_MODULE_ID;
      }
    },
    
    load(id) {
      if (id === RESOLVED_VIRTUAL_MODULE_ID) {
        // Return cached module if available (for HMR performance)
        if (cachedModule) {
          return cachedModule;
        }
        
        // Read and parse grammar
        const grammarJson = readFileSync(grammarPath, 'utf-8');
        const grammar = JSON.parse(grammarJson);
        
        // Extract and compile patterns
        const patterns = [...extractPatterns(grammar)];
        const compiled = compilePatterns(patterns);
        
        // Generate and cache module
        cachedModule = generateModule(compiled);
        
        console.log(`[compile-grammar] Compiled ${patterns.length} patterns`);
        
        return cachedModule;
      }
    },
    
    handleHotUpdate({ file }) {
      // Invalidate cache when grammar file changes
      if (file.endsWith('Luau.tmLanguage.json')) {
        cachedModule = null;
        console.log('[compile-grammar] Grammar changed, will recompile patterns');
      }
    },
  };
}

